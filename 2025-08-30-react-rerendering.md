### Q. React에서 리렌더링이란 무엇인가요?

리렌더링은 컴포넌트의 상태나 Props가 변경될 때, React가 UI를 다시 그리는 과정을 말한다.

이때 React는 Virtual DOM에 새로운 UI를 반영한 뒤, 이전 Virtual DOM과 비교하여 바뀐 부분만 실제 DOM에 적용한다.

즉, 불필요한 전체 렌더링을 막고, 필요한 부분만 효율적으로 업데이트한다.

---

### Q. 어떤 상황에서 컴포넌트가 리렌더링되나요?

컴포넌트가 리렌더링 되는 주요 원인은 크게 4가지이다.

1. **상태(State) 변화**
   - 해당 컴포넌트의 상태가 바뀌면 무조건 리렌더링된다.
   - 이는 `setState` 호출, 콜백 실행, `useEffect` 등의 훅에서 자주 발생한다.
2. **부모 컴포넌트 리렌더링**
   - 부모가 리렌더링되면 자식도 함께 리렌더링된다.
   - 리렌더링은 부모 → 자식 방향으로만 이어지고, 자식의 변화가 부모에게 영향을 끼치진 않는다.
3. **컨텍스트(Context) 값 변경**
   - Context Provider의 값이 바뀌면, 그 값을 사용하는 모든 컴포넌트가 리렌더링된다.
   - 직접 그 값 일부를 사용하지 않더라도 동일하게 영향을 받는다.
4. **훅(Hook) 내부 변화**
   - 훅에서 관리하는 상태가 변경되면 컴포넌트가 리렌더링된다.
   - 훅이 Context를 사용 중이라면, Context 값 변경 시에도 리렌더링된다.

---

### Q. 부모 컴포넌트가 리렌더링될 때 자식도 항상 리렌더링되나요?

기본적으로 부모가 리렌더링되면 자식도 함께 리렌더링 사이클을 돈다.

하지만 이것이 곧바로 “화면까지 다시 그려진다”는 뜻은 아니다.

자식 컴포넌트의 props가 이전과 동일하다면, 내부적으로 변화가 없으므로 실제 DOM 변경은 발생하지 않는다.

---

### Q. 불필요한 리렌더링을 막기 위한 방법은 무엇인가요?

리렌더링은 화면을 새로 그리는 과정인데, 필요 없는 리렌더링은 성능을 떨어트린다.

이를 막기 위해 React에서는 메모이제이션(Memoization)¹ 기법을 쓴다.

- **1. React.memo (컴포넌트 메모이제이션¹)**
  - **목적**: 부모가 리렌더링되더라도, 자식 컴포넌트의 props가 바뀌지 않았다면 리렌더링을 막는다.
  - **작동 방식**:
    1. 새 props와 이전 props를 얕은 비교(shallow compare)² 한다.
    2. 값이 모두 같으면 렌더링을 건너뛰고 이전 결과를 재사용한다.
  - **사용 시점**:
    - 내부 연산이 많거나 자식 컴포넌트가 복잡할 때
    - props가 자주 변하지 않는 컴포넌트에 적용
- **2. useCallback (함수 메모이제이션¹)**
  - **문제 상황**: 부모가 리렌더링될 때마다 내부에서 만든 함수도 새로 생성된다.
    → 새로 생성된 함수는 참조값이 달라져서, React.memo 자식에 내려주면 “props가 바뀌었다”고 판단 → 불필요한 리렌더링 발생.
  - **해결책**:
    - `useCallback`으로 함수를 감싸면, 의존성 배열의 값이 변하지 않는 한 같은 함수 참조를 계속 재사용한다.
  - **핵심**:
    - 빈 배열 `[]`을 주면 컴포넌트가 처음 마운트될 때 한 번만 만들어지고 이후로는 바뀌지 않는다.
    - 필요할 때만 함수가 새로 생성되도록 제어하는 것.
- **3. useMemo (값 메모이제이션¹)**
  - **목적**: 비용이 큰 계산 결과나 객체/배열을 저장해두고, 의존성이 바뀌지 않으면 다시 계산하지 않는다.
  - **사용 시점**:
    1. 복잡한 계산(큰 배열 정렬, 필터링 등)을 매번 다시 하는 게 부담될 때
    2. React.memo 자식에 객체/배열을 props로 줄 때 (매번 새로운 객체가 생성되는 문제 해결)
  - **핵심**:
    - 의존성 배열에 있는 값이 바뀔 때만 다시 계산하고, 그렇지 않으면 이전 계산 결과를 그대로 재사용한다.

---

### Q. useCallback, useMemo는 리렌더링과 어떤 관계가 있나요?

- **useCallback**:
  리렌더링될 때마다 함수가 새로 생성되는 문제를 막는다.
  → 예를 들어 전화번호를 이미 저장해놨는데, 전화를 걸 때마다 새 번호를 적는 것은 낭비다.
  → useCallback은 이미 저장해둔 번호를 계속 쓰듯, 같은 함수를 재사용하게 해준다.
- **useMemo**:
  리렌더링될 때마다 다시 계산되는 값을 메모이제이션¹ 한다.
  → “한 번 계산한 건 기억해두고, 값이 달라질 때만 다시 계산한다” 라는 개념이다.

---

### 각주

1. 한번 계산한 결과를 저장해두고, 같은 입력이면 다시 계산하지 않고 그대로 재사용하는 방식

2. 기본(원시) 타입의 경우 값을 직접 비교하지만, 참조 타입(객체, 배열 등)의 경우 값 자체가 아니라 참조하는 메모리 주소값만 비교하는 방식

---

### 학습에 참고한 자료

- 티스토리 - [React에서 렌더링이란 무엇일까? +DOM](https://1zung.tistory.com/55)
- 판다코딩 - [React 리랜더링 가이드 : 모든 것을 한 번에 | Panco](https://www.pancodev.io/article/react/react-re-renders-guide-everything-all-at-once)
- 안동민 개발노트 - [불필요한 리렌더링 이해와 방지 - 안동민 개발노트](https://andongmin.com/docs/react/ch10/ch10-2#reactmemo-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98)
